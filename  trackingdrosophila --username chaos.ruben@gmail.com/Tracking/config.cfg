 /* Example application configuration file */
     
//     version = "1.0";
//
//     application:
//     {
//       window:
//       {
//         title = "My Application";
//         size = { w = 640; h = 480; };
//         pos = { x = 350; y = 250; };
//       };
//
//       list = ( ( "abc", 123, true ), 1.234, ( /* an empty list */) );
//
//       books = ( { title  = "Treasure Island";
//                   author = "Robert Louis Stevenson";
//                   price  = 29.95;
//                   qty    = 5; },
//                 { title  = "Snow Crash";
//                   author = "Neal Stephenson";
//                   price  = 9.99;
//                   qty    = 8; } );
//
//       misc:
//       {
//         pi = 3.141592654;
//         bigint = 9223372036854775807L;
//         columns = [ "Last Name", "First Name", "MI" ];
//         bitmask = 0x1FC3;
//       };
//     };
     
/************** ARCHIVO DE CONFIGURACIÓN TRACKING_DROSOPHILA ****************
******                                                                ******
******	En este archivo se almacenan los parámetros de configuración  ******
******  de la aplicación. 					      					  ******
****** 								                                  ******
******	ADVERTENCIA: Modificar única y exclusivamente el campo        ******
******	correspondiente al valor del parámetro ( = valor ;)  	      ******
******  En caso contrario la ejecución del programa  podría fallar    ******
******  o bien podrían	producirse resultados inesperados en la misma ******
******                 						                          ******
******	Se recomienda fervientemente  guardar una copia se seguridad  ******
******	del fichero original así como copias de las configuraciones   ******
******	creadas por el usuario. En caso de no encontrarse el fichero  ******
******	se cargarán las opciones por defecto.			              ******
******								                                  ******	
****************************************************************************/
	
version = 1.0;	

/****************************** OPCIONES GENERALES DEL PROGRAMA *******************************/
	General:
	{
	   
		MAX_FLAT = false ;	// - Este parámetro se usa para calibrar la cámara
							// En caso de no introducir valor las medidas de las
							// distacias serán en pixels. Una vez encontrado el 
							// plato, se usará su ancho en píxels y el valor aquí
							// introducido para establecer los pixels por mm.
		
		FPS = NULL ;		// tasa de frames por segundo del vídeo. Se usa para 
							// para establecer la unidad de tiempo.
							// NOTA:  En algunos videos la obtención de la tasa
							// de frames es errónea, con el consiguiente error 
							// en las medidas que intervengan tiempos. Si se observa
							// que la tasa de frames indicada en la pantalla de 
							// visualización difiere de la real del video, se ha de
							// modificar este parámetro y establezcer la real. Se ha 
							// observado dicho fallo con archivos *.wmv. Se recomienda 
							// codificar los vídeos con MPEG en cualquiera de sus formatos.
							// Consultar documentación para mayor detalle.
		
		INIT_DELAY	= 50;  	// - Los primeros x frames serán ignorados.
							// incrementar o decrementar en función de la estabilidad
							// de la imagen en los primeros frames.
		
		MEDIR_TIEMPOS = false;		// - Activa la medición de tiempos de los distintos
									// módulos ( pre_procesado, procesado, tracking, 
									// estadísticas y visualización)
	}
	
	/******************************* MODULO DE ESTADÍSTICAS ******************************/
	
	Estadisticas:
	{		
	
		CALC_STATS_MOV = true; 			// Switch true/false para activar el cálculo de estadísticas de movimiento
										// de los blobs.
							
		
							
		MAX_TIME = 8;				// Establece el periodo máximo de la media móvil simple para el cálculo de
									// la cantidad de movimiento de los blobs en conjunto, o lo que es lo mismo,
									// el tamaño máximo del vector  que almacena las cantidades de movimiento
									// de cada frame.
									
									// VALORES: 0,1,2,4,8,16,24,48
														
									// Esto es, un valor de 1 indica que se calcularán estadísticas de la última hora como máximo.
									// y así sucesivamente hasta el máximo de 48 horas. Un valor de 0 indirá el máximo.
									
									// ACLARACIÓN: Suponiendo un Frame Rate de 30, un valor de 48 horas supondrá almacenar 
									// en memoria un vector de 7020000 elementos con el consiguiente coste computacional
									// y de memoria. 
		
		UMBRAL_ACTIVIDAD_ALTA 	=  ;		// Establece la velocidad media en mm/s a partir de la cual se considerará que un blob 
											// tiene actividad ALTA
		UMBRAL_ACTIVIDAD_MEDIA	= 1 ;		// Establece la velocidad media en mm/sa partir de la cual se considerará que un blob 
											// tiene actividad MEDIA
		
		UMBRAL_ACTIVIDAD_BAJA	=	;		// Establece la velocidad media en mm/s a partir de la cual se considerará que un blob 
											// tiene actividad BAJA
											
		UMBRAL_ACTIVIDAD_NULA	=	;		// Establece la velocidad media en mm/s a partir de la cual se considerará que un blob 
											// está incactivo
	}
	
	/******************************* MODULO DE VISUALIZACIÓN   ******************************/
	
	// OPCIONES GENERALES
	
	Visualización:
	{ 
		
		SHOW_WINDOW = true; 				// Switch GENERAL de 0 a 1 para mostrar la ventana de visualización
											// NOTA:Los siguientes parámetros no se tendrán en cuenta si no se activa 
		
		SHOW_PRESENT = true ;				// Switch de 0 a 1 para visualizar presentacion inicial.
							    
		SHOW_TRANSITION = true;				// Muestra una animaciones entre las distintas partes del proceso.
		
		CONTROLES_VISUALIZACION = true ;	// Activa controles de visualización:
											// Mientras se ejecuta el programa, si se pulsa:
							 				/* 	p : se pone en modo pausa hasta presionar c.	
							 				 	r : Inicia la grabación de un video con los resultados.
							 					s : Detiene la grabación del video
							 					f : Avanza frame a frame hasta presionar c. 
							 					c : Permite continuar con la ejecución normal. */
												g : Hace una captura de pantalla ( solo funciona en modo pausa )
													Se guarda en formato jpeg.
		
		
		MODO_COMPLETO = false;			// Switch GENERAL true/false para visualizar los resultados de los distintos módulos.
		
										// NOTA1: Al activar esta opción el rendimiento disminuirá de forma notable.
										
										// NOTA2: Los siguientes parámetros no se tendrán en cuenta si no se activa 
										// 	  	  el modo detallado.
		Completo:
		{	
			SHOW_BG_DIF_IMAGES  = false ; 		// Switch de 0 a 1 para visualizar las imagenes antes y despues de la limpieza de FG.
			
			// Resultados de preprocesado
			SHOW_LEARNING_FLAT = true;
			SHOW_INIT_BACKGROUND = true;
			SHOW_SHAPE_MODELING= true; 			// Switch true/false para visualizar los resultados del modelado de forma.
			
			// Resultados de procesado
			SHOW_PROCESS_STAGES = false ; 		// Switch true/false para visualizar los resultados del procesado etapa a etapa.			
			SHOW_VALIDATION_IMAGES = false;		// Switch true/false para visualizar las imagenes de la validación etapa a etapa.
			SHOW_BG_REMOVAL = true; 			// Switch true/false para visualizar el Background y Foreground.
			SHOW_KALMAN = true;
		}
	
	}
	
	/******************************* CONFIGURACION DEL MODULO DE PRE-PROCESADO  ******************************/
	
	Preprocesado:
	{		
											// MODELADO DE FONDO //	
											
		// Para detalles de configuración consultar la documentación del proyecto o bien:
		// - NIHMS109817-supplement-1
		// - Background subtraction techniques:a review. Massimo Piccardi */	
		// - Detecting Moving Objects, Ghosts, and Shadows in Video Streams. Rita Cucciara
		// - Learning OpenCv	
			    
		BackGroundModel:
		{	
			Inicializacion:
			
			{							
			/// PARÁMETROS INICALES
			
			FLAT_DETECTION = true;		// - Activa o desactiva la detección del plato.
											// La no detección afectará al rendimiento de la 
											// aplicación y a la calibración de la cámara. Si no se activa o bien no 
											// se logra detectar el plato, las medidas se establecerán en pixels/s
											
			FLAT_FRAMES_TRAINING = 500;		// Número de frames que se usarán para detectar el plato.
											// en caso de que falle la detección modificar este parámetro.
											// Si no se ha activado la detección este parámetro es ignorado. Si se establece
											// a 0, por defecto serán 500 frames. 
			
			MODEL_TYPE = 4;					// - El tipo de modelo puede ser:
											/*	1) GAUSSIAN 1 Modelo de Gaussiana simple sin actualización selectiva 
												2) GAUSSIAN_UP 2 Modelo de Gaussiana simple con actualización selectiva. 
											 	3) MEDIAN 3 Modelo de mediana simple sin actualización selectiva 
											 	4) MEDIAN_S_UP 4 Modelo de mediana simple con actualización selectiva 
											 			
			
			BG_Update = 5;					// Intervalo de actualización del fondo. Si el vídeo es muy ruidoso este 
											// parámetro debería ser 1 o próximo a 1. 
			
			initDelay = 50;					// - Los primeros x frames serán ignorados.
											// incrementar o decrementar en función de la estabilidad
											// de la imagen en los primeros frames.
			
			Jumps = 4;						// Con el fin de lograr un modelo de fondo limpio de blobs, se efectúan saltos
											// a lo largo del vídeo para minimizar la posibilidad de que blobs estáticos 
											// formen parte del fondo. Se consigue así una detección de todos los blobs en 
											// la primera iteración del procesado.			
			
			FRAMES_TRAINING = 700;			// - Frames de entrenamiento para el aprendizaje del fondo.
											// Establecer un valor tal que la imagen del fondo aparezca limpia de blobs.				
								 
			INITIAL_DESV = 0.05;			// - Establece la desviación inicial del modelo de fondo gaussiano. 
											// Para fondos unimodales y poco ruidosos un valor bajo. NIHMS109817-supplement-1
											
			K = 0.6745;						//Para la corrección de la MAD ( Median Absolute Deviation )
											//con el que se estima la desviación típica para el modelo gaussiano.
			
		}	
										// MODELADO DE FORMA //		
		
		// Para detalles de configuración consultar la documentación del proyecto o bien:
		// - NIHMS109817-supplement-1
		// - Background subtraction techniques:a review. Massimo Piccardi */	
		// - Detecting Moving Objects, Ghosts, and Shadows in Video Streams. Rita Cucciara
		// - Learning OpenCv	
		
		ShapeModel:								
		{
			BGModel:
			{						
				LOW_THRESHOLD = 15;						
				
				/// PARAMETROS PARA LA LIMPIEZA DEL FG
				
				MORFOLOGIA = true;			
				CVCLOSE_ITR = 1;			
				MAX_CONTOUR_AREA = 0 ; 			
				MIN_CONTOUR_AREA = 0; 			
				HIGHT_THRESHOLD = 20;		
			}		
			
			Max_Area = 100					// Al modelar la forma, se excluirán del cálculo aquellos blobs con un área mayor de Max_area Pixels
				
			Max_Perimeter = 1000				// Al modelar la forma, se excluirán del cálculo aquellos blobs con un perímetro mayor de Max_Perimeter Pixels
		}
	}

	/******************************* CONFIGURACION DEL MODULO DE PROCESADO  ******************************/
			
	Procesado:
	{		
			BGModel:
			{			
				MODEL_TYPE = 4;			
				BG_Update = 10;			
				K = 0.6745;					
				LOW_THRESHOLD = 15;			
				
				/// PARAMETROS PARA LA LIMPIEZA DEL FG
				
				MORFOLOGIA = true;			
				CVCLOSE_ITR = 1;			
				MAX_CONTOUR_AREA = 0 ; 			
				MIN_CONTOUR_AREA = 0; 			
				HIGHT_THRESHOLD = 20;		
	 		}
	 		
	 		// Para detalles de configuración consultar la documentación del proyecto o bien:
			// - NIHMS109817-supplement-1
			
	 		Validacion:
	 		{
	 			BGModel:
	 			{
				 	MODEL_TYPE = MEDIAN_S_UP;	
				 	Params->MORFOLOGIA = false;
					CVCLOSE_ITR = 0;
					MAX_CONTOUR_AREA = 0 ;
					MIN_CONTOUR_AREA = 0;				
					HIGHT_THRESHOLD = 20;
					LOW_THRESHOLD = 15;
				}
				
				UmbralCirc = 0;
				Umbral_H = 5.0;		// Establece el tamaño máximo del blob válido en 5 desviaciones típicas de la media
									// Cuando un blob tiene un defecto de area, para verificar que no se trata de un espurio,
									// se aumenta el umbral en la resta de fondo para comprobar si su area aumenta. Este umbral
									// establece el límite de dicho aumento.
									
									
				Umbral_L = 5.0;		// Establece el tamaño mínimo del blob válido en 5 desviaciones típicas de la media			
									// Cuando un blob tiene un exceso de area, se incrementa paulatinamente el umbral de la
									// resta de fondo con el fin de reducir progresivamente su area. Como consecuencia,
									// si dicho blob está formado por dos moscas, esto provocará su fición para un determinado
									// umbral. El límite de dicho umbral es Umbral_L. Para mas detalles consultar documentación
									// o bien el artículo NIHMS109817-supplement-1																
				
				MaxDecLTHIters = 100; 	// número máximo de veces que se podrá decrementar el umbral bajo
									
				MaxIncLTHIters= 20;  	// número máximo de veces que se podrá incrementar el umbral bajo
				MaxLowTH = 1000; 		// límite superior para el umbral bajo ( exceso )
				MinLowTH = 1;		 	// límite inferior para el umbral bajo ( defecto )
			}							
	}
	
	/******************************* CONFIGURACION DEL MODULO DE TRACKING  ******************************/
	
	Tracking:
	{
	
		MAX_BLOBS = 10 ;			// Número máximo de elementos a rastrear	
									 
		MAX_BUFFER = 50 ;			// Longitud del buffer. El módulo de tracking mantiene en memoria un número de frames 
									// igual al valor introducido. Supondría almacenar MAX_BUFFER / FPS segundos de video.
									// Cuanta mayor sea la longitud del buffer, más eficaz será la fase de corrección y 
									//  a la vez mayores serán las necesidades de memoria, con lo que un valor demasiado alto podría 
									// afectar seriamente al rendimiento del equipo y por consiguiente, de la aplicación.
									// Para un con procesador Intel(R) Pentium(R) M a 1.73GHz y 1 Gb de RAM
									// corriendo Ubuntu 10.10 y GNOME 2.32.0 se aconseja un máximo de 80
		
		MAX_TIME_SLEPT 200			// Marca un tiempo máximo en farmes a partir del cual se eliminará un track. Dicho track ha 
									// de cumplir ciertas condiciones para ser eliminado:
									// 1) Haber perdido el objeto a rastrear y no encontrarlo durante MAX_TIME_SLEPT frames
									// 2) Ser un track no prioritario, es decir, un track cuya de id sea superior al número máximo de blobs									

		NUMBER_OF_IDENTITIES 100	// Número máximo de identidades que se podrán asignar a los tracks. Cada vez que se crea un track, se le 
									// asigna una identidad. Durante la ejecución pueden crearse tracks para falsos blobs ( por ejemplo reflejos)
									// que serán posteriormente eliminados.
									
		// Configuración del filtro de kalman. ¡ SEA CUIDADOSO !. Para más detalles consultar documentación o el artículo
		// Stochastic models, estimation, and control VOLUME1 PETER S: MAYBECK 1979
		// Kalman Filters: A tutorial 1999
		// Observadores de Estado en Procesos Estocásticos: El Filtro de Kalman. Daniel Pizarro Pérez
		// Learning OpenCv.
	
		Kalman:
		{						
			Inicializacion:
			{
				VELOCIDAD  5.3 //10.599 	// velocidad inicial del blob en pixeles por frame
				V_ANGULAR 2.6//5.2 			//  velocidad angular del blob en pixeles por frame
				
				measurement_noise = {0,0,0,0,0};															// V->N(0,R)
				measurement_noise_cov = {100,0,0,0,0, 0,100,0,0,0, 0,0,200,0,0, 0,0,0,200,0, 0,0,0,0,360};	//( Rx, Ry, RVx, RVy, Rphi );
				measurement_matrix = ;																		// H Matriz de medida
				process_noise_cov = ; // error asociado al modelo del sistema 								// Q = f(F,B y H).
				error_cov_pre = ; 																			// Incertidumbre en predicción. 
																											//(P_k' = F P_k-1 Ft) + Q. 
																											// Inicialmente se establece a 1
				error_cov_post = ;																			// Incertidumbre tras añadir medida. 
																											//	P_k = ( I - K_k H) P_k'
				
			}
			
			CamControl:
			{
				measurement_noise = {0,0,0,0,0}; // V->N(0,R)
				measurement_noise_cov_t_0 = ;	
				TiempoEstab = ;
				measurement_noise_cov_t = ;
				
			}
			KalmanControl:
			{
				measurement_noise = {0,0,0,0,0}; // V->N(0,R)
				measurement_noise_cov_t_0 = ;	
				TiempoEstab = ;
				measurement_noise_cov_t = ;
			}
			
		}
	}
			
			
			
			
