      
/************** ARCHIVO DE CONFIGURACIÓN TRACKING_DROSOPHILA ****************
******                                                                ******
******	En este archivo se almacenan los parámetros de configuración  ******
******  de la aplicación. 					      					  ******
****** 								                                  ******
******	ADVERTENCIA: Modificar única y exclusivamente el campo        ******
******	correspondiente al valor del parámetro ( = valor ;)  	      ******
******  En caso contrario la ejecución del programa  podría fallar    ******
******  o bien podrían	producirse resultados inesperados en la misma.******
******                 						                          ******
******	Se recomienda encarecidamente  guardar una copia se seguridad  ******
******	del fichero original así como copias de las configuraciones   ******
******	creadas por el usuario. En caso de no encontrarse el fichero  ******
******	se cargarán las opciones por defecto.			              ******
******								                                  ******	
****************************************************************************/
	
version = 1.0;	

/**** CONSIDERACIONES PREVIAS ACERCA DE LA CONFIGURACIÓN ****/

/*	Antes de modificar parámetros de configuración del fichero, se deberán tener en cuenta los siguientes aspectos:
	- Se ha de respetar de forma estricta la notación los tipos de datos de las variables (valores numéricosenteros, 
	decimales y booleanos. Aquellos valores que figuren con notación entera deberán seguir con dicha notación.
	Lo mismo es válido para de notación decimal y booleana.
	Si un valor decimal 0.0  se cambia al entero 0, prodría provocar errores en la lectura. 
	Un valor booleano sólo deberá tomar los valores true (1) o false (0).
	- Un fallo en la lectura de la variable o un valor incorrecto del parámetro provocará la carga del valor por defecto.
	Se informará por consola del parámetro afectado y del valor asignado.
	- Si en un campo la opción Auto se establece a true, los valores de las variables de dicho  campo serán ignorados 
	y se establecerán los valores por defecto. NOTA. no todos los campos disponen de esta opción.
	- Existe la posibilidad de establecer ciertos parámetros de forma automática a pesar de no establecer el modo auto. 
	Si es así se indicará en los comentarios de dicha variable. 
*/ 

/****************************** OPCIONES GENERALES DEL PROGRAMA *******************************/
	General:
	{
	    Auto = false;
	    
		MaxFlat = 125.0 ;	// VALORES: Diámetro del plato en mm. 
							//	- Este parámetro se usa para calibrar la cámara
							// En caso de no introducir valor las medidas de las
							// distacias serán en pixels. Una vez encontrado el 
							// plato, se usará su ancho en píxels y el valor aquí
							// introducido para establecer los pixels por mm.
		
		FPS = 15;		    // tasa de frames por segundo del vídeo. Se usa para 
							// para establecer la unidad de tiempo.
							
							// Un valor 0 indica detección automática
							
							// NOTA:  En algunos videos la obtención de la tasa
							// de frames es errónea, con el consiguiente error 
							// en las medidas que intervengan tiempos. Si se observa
							// que la tasa de frames indicada en la pantalla de 
							// visualización difiere de la real del video, se ha de
							// modificar este parámetro y establezcer la real. Se ha 
							// observado dicho fallo con archivos *.wmv. Se recomienda 
							// codificar los vídeos con MPEG en cualquiera de sus formatos.
							// Consultar documentación para mayor detalle.
		
		TotalFrames = 9570.0;	// Número de frames que contiene el vídeo. Se usa para 
							// establecer el progreso y realizar los saltos en 
							// el modelo de fondo.
							
							// Un valor 0 indica detección automática
							
							// NOTA: Como en el caso de FPS, en algunos formatos de vídeo
							// puede resultar errónea. En dicho caso, introducir aquí el 
							// valor correcto.
		
		InitDelay = 50;  	// - Los primeros x frames serán ignorados.
							// incrementar o decrementar en función de la estabilidad
							// de la imagen en los primeros frames.
							
							// Un valor -1 indica valor por defecto
		
		MedirTiempos = false;		// - Activa la medición de tiempos de los distintos
									// módulos ( pre_procesado, procesado, tracking, 
									// estadísticas y visualización)
	};
	
	/******************************* MODULO DE ESTADÍSTICAS ******************************/
	
	Estadisticas:	
	{		
		Auto = false;				// Si true, se establecerán los parámetros por defecto.
		
		CalcStatsMov = true; 		// Switch true/false para activar el cálculo de estadísticas de movimiento
												
							
		MaxBufferTime = 234000;		// Establece el periodo máximo (en segundos) de la media móvil simple para el cálculo de
									// la cantidad de movimiento de los blobs en conjunto, o lo que es lo mismo,
									// el tamaño máximo del vector  que almacena las cantidades de movimiento
									// de cada frame.
									
									// VALORES: 1,30,60,300,600,900,1800,3600, 7200,14400, 28800,57600,115200,234000
														
									// Esto es, un valor de 1 indica que se calcularán estadísticas del último segundo.
									// y así sucesivamente hasta el máximo de 234000 (48 horas). Un valor de 0 indirá el máximo.
									
									// ACLARACIÓN: Suponiendo un Frame Rate de 30, un valor de 48 horas supondrá almacenar 
									// en memoria un vector de 7020000 elementos con el consiguiente coste computacional
									// y de memoria.
		
		MuestrearLinea = false;		// Realiza un muestreo del brillo de los píxels de una línea horizontal de 100 pixels
									// situada en torno al centro de la imagen. El resultado se almacena en un fichero de tipo .csv
									// separado por ;
									// Su uso está indicado para realizar una calibración precisa del modelo de fondo tras un análisis estadístico
									// de los datos.
		
		
	};
	
	/******************************* MODULO DE VISUALIZACIÓN   ******************************/
	
	// OPCIONES GENERALES
	
	Visualizacion:
	{ 
		Auto = false;
		
		RecWindow = false;					// Switch de 0 a 1 para grabar la ventana de visualización.
											// puede ser activado o no independientemente de que se active o no el general.
		
		ShowWindow = true; 					// Switch GENERAL de 0 a 1 para mostrar la ventana de visualización
											// NOTA:Los siguientes parámetros no se tendrán en cuenta si no se activa 
		
		ShowPresent = false;				// Switch de 0 a 1 para visualizar presentación inicial.
							    
		ShowTransition = false;				// Muestra una animaciones entre las distintas partes del proceso.
		
		HightGUIControls = true;			// Activa controles de visualización:
											// Mientras se ejecuta el programa, si se pulsa:
							 				/* 	p : se pone en modo pausa hasta presionar c.	
							 				 	r : Inicia la grabación de un video con los resultados.
							 					s : Detiene la grabación del video
							 					f : Avanza frame a frame hasta presionar c. 
							 					c : Permite continuar con la ejecución normal. 
												g : Hace una captura de pantalla ( solo funciona en modo pausa )
													Se guarda en formato jpeg.*/
													
		ShowStatsMov = true;				// Switch de 0 a 1 para visualizar las estadísticas de movimiento en la ventana de tracking.	
		
		ModoCompleto = false;			// Switch GENERAL true/false para visualizar los resultados de los distintos módulos.
		
										// NOTA1: Al activar esta opción el rendimiento disminuirá de forma notable.
										
										// NOTA2: Los siguientes parámetros no se tendrán en cuenta si no se activa 
										// 	  	  el modo detallado.	
		
			
		ShowBGdiffImages  = false ; 		// Switch de 0 a 1 para visualizar las imagenes antes y despues de la limpieza de FG.
		
		// Resultados de preprocesado
		ShowLearningFlat = true;
		ShowInitBackground = true;
		ShowShapeModel= true; 			// Switch true/false para visualizar los resultados del modelado de forma.
		
		// Resultados de procesado
		ShowProcessPhases = false ; 		// Switch true/false para visualizar los resultados del procesado etapa a etapa.			
		ShowValidationPhases = false;		// Switch true/false para visualizar las imagenes de la validación etapa a etapa.
		ShowBGremoval = true; 			// Switch true/false para visualizar el Background y Foreground.
		ShowKalman = true;
	
	
	};
	


	/******************************* CONFIGURACION DEL MODULO DE PRE-PROCESADO  ******************************/
	
	Preprocesado:
	{		
											// MODELADO DE FONDO //	
											
		// Para detalles de configuración consultar la documentación del proyecto o bien:
		// - NIHMS109817-supplement-1
		// - Background subtraction techniques:a review. Massimo Piccardi */	
		// - Detecting Moving Objects, Ghosts, and Shadows in Video Streams. Rita Cucciara
		// - Learning OpenCv	
		
		Auto = false;
			    
		InitBackGroundModel:
		{											
			/// PARÁMETROS INICALES
			
			Auto = false;
			
			FlatDetection = true;			// - Activa o desactiva la detección del plato.
											// La no detección afectará al rendimiento de la 
											// aplicación y a la calibración de la cámara. Si no se activa o bien no 
											// se logra detectar el plato, las medidas se establecerán en pixels/s
											
			FLAT_FRAMES_TRAINING = 500;		// Número de frames que se usarán para detectar el plato.
											// en caso de que falle la detección modificar este parámetro.
											// Si no se ha activado la detección este parámetro es ignorado. Si se establece
											// a 0, por defecto serán 500 frames. 
			
			MODEL_TYPE = 4;					// - El tipo de modelo puede ser:
											/*	1) GAUSSIAN 1 Modelo de Gaussiana simple sin actualización selectiva 
												2) GAUSSIAN_UP 2 Modelo de Gaussiana simple con actualización selectiva. 
											 	3) MEDIAN 3 Modelo de mediana simple sin actualización selectiva 
											 	4) MEDIAN_S_UP 4 Modelo de mediana simple con actualización selectiva */
											 			
			
			BG_Update = 5;					// VALOR: Entero. [ 1 , 20 ]
											// Intervalo de actualización del fondo. Si el vídeo es muy ruidoso este 
											// parámetro debería ser 1 o próximo a 1.
											// Si se establece a 0, por defecto será 1. 
			
			initDelay = 50;					// VALOR: Entero. [ 0 , -- ]
											// - Los primeros x frames serán ignorados.
											// incrementar o decrementar en función de la estabilidad
											// de la imagen en los primeros frames.
			
			Jumps = 10;						// VALOR: Entero. [ 0 , -- ]
											// Con el fin de lograr un modelo de fondo limpio de blobs, se efectúan saltos
											// a lo largo del vídeo para minimizar la posibilidad de que blobs estáticos 
											// formen parte del fondo. Se consigue así una detección de todos los blobs en 
											// la primera iteración del procesado.			
			
			FRAMES_TRAINING = 700;			// VALORES: [ 100, -- ]
											// - Frames de entrenamiento para el aprendizaje del fondo.
											// Establecer un valor tal que la imagen del fondo aparezca limpia de blobs.				
								 
			INITIAL_DESV = 0.05;			// - Establece la desviación inicial del modelo de fondo gaussiano. 
											// Para fondos unimodales y poco ruidosos un valor bajo. NIHMS109817-supplement-1
											
			K = 0.6745;						//Para la corrección de la MAD ( Median Absolute Deviation )
											//con el que se estima la desviación típica para el modelo gaussiano.
											//Esta K también se usará en las actualizaciones del modelo de forma
			
		};	
										// MODELADO DE FORMA //		
		
		// El ajuste de los siguientes parámetros configura el modelado de forma. El área media
		// de los blobs y su desviación puede variar significativamente con su modificación.
		// Afectará al módulo de validación haciendo ésta más o menos restrictiva. 
		
		// Para detalles de configuración consultar la documentación del proyecto o bien:
		// - NIHMS109817-supplement-1
		// - Background subtraction techniques:a review. Massimo Piccardi 	
		// - Detecting Moving Objects, Ghosts, and Shadows in Video Streams. Rita Cucciara
		// - Learning OpenCv	
				
		ShapeModel:	
		{	
		
			Auto = false;
			
			LOW_THRESHOLD = 15;				// VALORES: Enteros [1,255]
											// Se recomienda entre 1 y 25 dependiendo
											// del contraste entre fondo y primer plano
											// Umbral en la resta de fondo. A patir del
											// valor establecido los objetos serán considerados
											// FG. A medida que aumenta, disminuye el área 
											// de los blobs.		
			
			/// PARAMETROS PARA LA LIMPIEZA DEL FG
			
			MORFOLOGIA = true;				// Aplica operaciones de morfología (erosión y dilatación)
											// en la imagen resultante de la resta de fondo	
			CVCLOSE_ITR = 1;				// Número de veces que se aplica morfología.
			MAX_CONTOUR_AREA = 0 ; 			// Los blobs de áreas superiores a MAX_CONTOUR_AREA serán eliminados
			MIN_CONTOUR_AREA = 10; 			// VALOR: pixels- Los blobs de áreas inferiores a MIN_CONTOUR_AREA píxels serán eliminados
			HIGHT_THRESHOLD = 20;			// Umbral Alto para la limpieza del foreground. Tras la resta de fondo,
											// Los blobs que no tengan algún pixel que supere dicho valor, serán eliminados. 
											//	Su ajuste permite eliminar ruido, sombras, etc
											
			SHOW_DATA_AREAS = true;		// Visualiza en consola el resultado del modelo de forma.
			
			FramesTraining = 200;			// número de frames de entrenamiento para el modelo de forma.
						
			Max_Area = 100					// Al modelar la forma, se excluirán del cálculo aquellos blobs con un área mayor de Max_area Pixels
				
			Max_Perimeter = 1000			// Al modelar la forma, se excluirán del cálculo aquellos blobs con un perímetro mayor de Max_Perimeter Pixels
				
		};
	};

	/******************************* CONFIGURACION DEL MODULO DE PROCESADO  ******************************/
			
	Procesado:
	{		
			Auto = false;
			
			BGModel:
			{	
				Auto = false;
						
				MODEL_TYPE = 4;			
				BG_Update = 10;			
				K = 0.6745;					
				LOW_THRESHOLD = 15;			
				
				/// PARAMETROS PARA LA LIMPIEZA DEL FG
				
				MORFOLOGIA = true;			
				CVCLOSE_ITR = 1;			
				MAX_CONTOUR_AREA = 0 ; 			
				MIN_CONTOUR_AREA = 0; 			
				HIGHT_THRESHOLD = 20;		
	 		};
	 		
	 		// Para detalles de configuración consultar la documentación del proyecto o bien:
			// - NIHMS109817-supplement-1
			
	 		Validacion:
	 		{
	 			Auto = false;	 			
	 				
 				/// PARAMETROS PARA LA LIMPIEZA DEL FG
			 	MODEL_TYPE = 4;	
			 	MORFOLOGIA = false;
				CVCLOSE_ITR = 0;
				MAX_CONTOUR_AREA = 0 ;
				MIN_CONTOUR_AREA = 0;				
				HIGHT_THRESHOLD = 20;
				LOW_THRESHOLD = 15;
				
				/// PARÁMETROS DE VALIDACIÓN ///
				
				UmbralCirc = 0;
				
				Umbral_H = 5.0;		// Establece el tamaño máximo del blob válido en 5 desviaciones típicas de la media
									// Cuando un blob tiene un defecto de area, para verificar que no se trata de un espurio,
									// se aumenta el umbral en la resta de fondo para comprobar si su area aumenta. Este umbral
									// establece el límite de dicho aumento.
									
									
				Umbral_L = 5.0;		// Establece el tamaño mínimo del blob válido en 5 desviaciones típicas de la media			
									// Cuando un blob tiene un exceso de area, se incrementa paulatinamente el umbral de la
									// resta de fondo con el fin de reducir progresivamente su area. Como consecuencia,
									// si dicho blob está formado por dos moscas, esto provocará su fisión para un determinado
									// umbral. El límite hasta el que se incrementará dicho umbral lo establece indirectamente Umbral_L. 
									
									// NOTA: Si el parámetro es muy restrictivo ( muy bajo ) puede provocar que nunca se llegue 
									// al umbral necesario para que se produzca la fisión.
									// Para mas detalles consultar documentación o bien el artículo NIHMS109817-supplement-1
				
				Umbral_MinArea = 5;		// VALORES: [ 5, -- ]. Un 0 indicará que se ignore el parámetro.
										// En caso de establecer un umbral de área, dicho valor tendrá prioridad frente al Umbral_L
										// El límite del aumento del umbral bajo será el que corresponda al área aquí introducida.
										
										// NOTA: Un valor muy bajo puede provocar que no se consiga segmentar ( aproximar a una elipse )
										// el área del blob, lo cual podría provocar errores en el procesado y consecuentemente en el tracking.															
				
				MaxDecLTHIters = 100; 	// número máximo de veces que se podrá decrementar el umbral bajo. 
									
				MaxIncLTHIters= 100;  	// número máximo de veces que se podrá incrementar el umbral bajo.
										// NOTA: Un valor muy pequeño podría provocar que no se llegase al umbral necesario para producir la fisión.
				
				MaxLowTH = 1000; 		// límite superior para el umbral bajo ( exceso )
										// NOTA: Un valor muy pequeño podría provocar que no se llegase al umbral necesario para producir la fisión.
				
				MinLowTH = 1;		 	// límite inferior para el umbral bajo ( defecto )
			};							
	};
	
	/******************************* CONFIGURACION DEL MODULO DE TRACKING  ******************************/
	
	TrackingParams:
	{
		// Generales		
		
		Auto = false;		
	
		MaxBlobs = 10 ;				// Número máximo de elementos a rastrear	
		
		CleanGhosts = true;			// Por el momento esta opción solo es efectiva para platos circulares y si y solo si se ha 
									// realizado el calibrado correctamente. Se eliminarán automáticamente aquellos tracks creados
									// por un reflejo en el borde del plato. En caso de no poder activarse, el fichero de datos podría
									// contener más tracks de los inicialmente establecidos. Para evitarlo en lo posible en el software 
									// se han implementado heurísticas para intentar detectar y eliminar dichos tracks.
									
		UmbralCleanGHost = 3 ;		// VALORES [1 , --] Unidad: mm
									// Establece la zona de trabajo del módulo de limpieza de reflejos.									
									// Zona a validar =  R +- UmbralCleanGHost;
		
		ShowKalmanData = false ;
		
									 
		MaxBuffer = 50 ;			// Longitud del buffer. El módulo de tracking mantiene en memoria un número de frames 
									// igual al valor introducido. Supondría almacenar MAX_BUFFER / FPS segundos de video.
									// Cuanta mayor sea la longitud del buffer, más eficaz será la fase de corrección y 
									//  a la vez mayores serán las necesidades de memoria, con lo que un valor demasiado alto podría 
									// afectar seriamente al rendimiento del equipo y por consiguiente, de la aplicación.
									// Para un con procesador Intel(R) Pentium(R) M a 1.73GHz y 1 Gb de RAM
									// corriendo Ubuntu 10.10 y GNOME 2.32.0 se aconseja un máximo de 80
		
		MaxTimeSlept = 200;			// Marca un tiempo máximo en farmes a partir del cual se eliminará un track. Dicho track ha 
									// de cumplir ciertas condiciones para ser eliminado:
									// 1) Haber perdido el objeto a rastrear y no encontrarlo durante MAX_TIME_SLEPT frames
									// 2) Ser un track no prioritario, es decir, un track cuya de id sea superior al número máximo de blobs									

		NumberOfIdentities = 100;	// Número máximo de identidades que se podrán asignar a los tracks. Cada vez que se crea un track, se le 
									// asigna una identidad. Durante la ejecución pueden crearse tracks para falsos blobs ( por ejemplo reflejos)
									// que serán posteriormente eliminados.
									
		// Estadísticas de los tracks
		
		PeriodoVelMed = 1.0 ; 	
									// Establece el período de tiempo (en segundos) para el cual se calcula la media móvil de 
									// la velocidad de cada blob. Un valor demasiado alto afectaría al rendimiento.
											
									// ACLARACIÓN: Suponiendo un Frame Rate de 30 y un período de 30 , se calcularía la  
									// velocidad media de un segundo. ( pixels/s ).
																				
		MediumActivityTh = 10.0 ;	// VALORES: si se ha calibrado en mm/s, sino en pixels/frame.
									// Establece el umbral de velocidad media (en mm/s). 
									// Actividad MEDIA si Vmed = ( LowActivityTh, MediumActivityTh ]
									// Si supera el umbral MediumActivity, se considerará que tiene una actividad alta.
		
		LowActivityTh = 5.0 ;		//VALORES: si se ha calibrado en mm/s, sino en pixels/frame.
									// Establece el umbral de velocidad media (en mm/s). 
									// Actividad BAJA si Vmed = ( NullActivityTh, LowActivityTh ]
											
		NullActivityTh = 0.2 ;		//VALORES: si se ha calibrado en mm/s, sino en pixels/frame.
									// Establece el umbral de velocidad media (en mm/s)
									// si Vmed <= NullActivityTh  el blob permanece INACTIVO
		
	};

		/******************************* CONFIGURACION DEL FILTRO DE KALMAN  ******************************/	
		
		/* Configuración del filtro de kalman. ¡ SEA CUIDADOSO !. 
		 Por cada elemento a rastrear se crea un track y se inicia un filtro de kalman. Éste tiene dos finalidades:
		 - Por un lado  se usa para realizar una predicción de la posición de la mosca en el instante t+1.
		 - Por otro lado se usa para realizar un filtrado en la dirección del blob, ya se ve muy afectada por el ruido.
		 Para más detalles consultar documentación o el artículo
		 Stochastic models, estimation, and control VOLUME1 PETER S: MAYBECK 1979
		 Kalman Filters: A tutorial 1999
		 Observadores de Estado en Procesos Estocásticos: El Filtro de Kalman. Daniel Pizarro Pérez
		 Learning OpenCv.*/
	
		Kalman:
		{		
		
			Auto = false;			
							
			Inicializacion:
			{
				Velocidad = 10.6; //5.3 		//VALORES: si se ha calibrado en mm/s, sino en pixels/frame.
												// velocidad inicial del blob en mm/s
												
				V_Angular = 0.0 ; //5.2 		//VALORES: en º/s
												// velocidad angular inicial del blob en º/s
				
				MaxJump = 25.0;					//VALORES: mm 
												//Máxima distancia aproximada que podría saltar una mosca en un frame
												
				
				T_Vmed = 0.33;					//VALORES: [1, 20]
												// Especifica el número máximo de frames que se retrocede para calcular la media
												// de la velocidad que usará Kalman como dato.
				
				MaxBack = 5;				// Cuando el blob está en movimiento, Se intenta disminuir el error en el cálculo de 
											// la dirección hasta MaxVPhiError
											// retrasando el origen del vector velocidad, hasta cierto límite .
											// Este valor marca dicho límite. 
											
											// NOTA: Este parámetro está muy relaccionado con los fps y la resolución.
											// En una resolución elevada dicho parámetro apenas influye, sin embargo es
											// determinante en vídeos de poca resolución ya que filtra enormente el ruido
											// en la dirección. 
											
				MaxVPhiError = 10;			//VALORES: en º
											// Error máximo permisible para el cálculo de la dirección. Mientras no se alcance
											// dicho error se retrocederá hasta un máximo de MaxBack frames para aumentar la 
											// resolución.												
				
				Q = 1.0 ;					// Q: error asociado al modelo del sistema Wk->N(0,Q): Q = f(F,B y H).
											// Afecta a la velocidad de convergencia.	
											// En la práctica se usa para representar lo que se desconoce
											// del modelo Q = ( B,F,H ). P_k' = F P_k-1 Ft + Q
											// El valor indica la unidad a la que se inicia la matriz   
																										 
				R0 = 1;						// Covarianza del ruido. Inicialmente se establece un valor elevado ya que ésta 
											// puede diferir en 180º de la real.								
										
											// R = {  R_x = R0 ,R_y = R0, R_Vx = 2*R0 , R_Vy = 2*R0, R_phiZk = 360};																								

			};
			
			/* Estado normal del filtro. Recibe nueva medida y ésta se corresponde con el blob al que sigue.
			   El ruido será el asociado al sistema de adquisición de imagen. En futuras mejoras está previsto implementar 
			   un método de cuantificación del ruido para ajustar los parámetros alpha de forma automática*/
			   
			CamControl:
			{
				alpha_Rk = 1;
				
				AlphaR_phi = 1;
				
						
				/* measurement_noise_cov = {	R_x = alpha_Rk*1, 
												R_y = alpha_Rk*1, 
												R_Vx = alpha_Rk + errorVx, 
												R_Vy = alpha_Rk + errorVy, 
												R_phiZk = AlphaR_phi + errorVPhi };   */
				
			};
			
			/* Estado de oclusión ( choque de blobs). Recibe una nueva medida, sin embargo tendrá una incertidumbre mayor que
			   en el caso de CamControl ya que los elementos objeto del rastreo han chocado y no se distingue con precisión 
			   la posición de cada uno.
			   Este valor modifica la ganancia K del filtro. Dicha ganancia
			   será menor cuanto mayor sea la incertidumbre en la medida. Esto implica que al aumentar la incertidumbre, en la fase
			   de corrección tendrá más peso el valor de la predicción del filtro para el instante t + 1 que el valor de la nueva 
			   medida de t+1. Se ven afectadas por lo tanto la fase de corrección, y posteriormente la fase de predicción.*/
			   
			KalmanControl:
			{
				alpha_Rk = 1;
				
				AlphaR_phi = 1;
				
				/* measurement_noise_cov = {
												R_x = alpha_Rk*Fly->Roi.width/2; // Un factor por la anchura/2 del rectángulo que contiene al blob
												R_y = alpha_Rk*Track->Fly->Roi.height/2; //Un factor por la altura/2 del rectángulo que contiene al blob
												R_Vx = alpha_Rk*2*R_x; // factor por 2 veces el error en la posición x.
												R_Vy = alpha_Rk*2*R_y;
												R_phiZk = AlphaR_phi ;
				*/					
				
			};
			
		};
	
			
			
			
			